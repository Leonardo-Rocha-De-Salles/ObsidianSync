
Cerchiamo di capire come i nostri programmi possono essere "exploitati" tramite undefined behaviours.

Quando mi vengono presentate davanti delle sequenze di byte, non siamo in  grado di capirne il contesto, interpretando delle informazioni non intese dal programma.

Quando succede possono esserci delle *binary exploitation* nel nostro programma, dove delle inserizioni di codice possono manipolare il nostro programma.

Vediamo delle possibili casistiche di *Exploitation*

# Buffer Overflow

Se vogliamo prendere degli input da testiera, abbiamo bisogno di funzioni che si interfacciano con hardware.

![[Pasted image 20241126123657.png]]

Creiamo nello stack uno spazio di memoria, quindi quando prendo in input dei dati, avrò un'area di memoria  che vive nel contesto dati, altri nel contesto istruzione per esempio **RET**.

Se in qualche modo l'utente riesce a sovrascrivere l'istruzione RET può decidere a quale indirizzo di memoria ritorna.

Possono essere scritti all'interno del contesto dati delle istruzioni che vengono considerate valide. In modo da sovvertire il funzionamento del nostro programma. Per esempio scrivo dello **Shellcode** in memoria e reindirizzo il flusso di esecuzione allo shellcode sempre utilizzando lo scanf.

![[Pasted image 20241126124205.png]]

**execve("/bin/sh");** avvia lo shell. Dato che quel percorso rappresenta uno spazio di memoria in ASCII.

![[Pasted image 20241126124509.png]]

L'indirizzo di ritorno richiama il nostro buffer che abbiamo inserito.

# Return Oriented Programming 101

I sistemi più moderni sia come sistema operativi che processori impediscono l'esecuzione di codice sullo stack.

Però l'indirizzo di ritorno possiamo sempre sovrascrivere il nuovo indirizzo di ritorno.

Quindi cosa possiamo farci nuovamente?

Se non si può inserire del codice nello stack, è possibile manipolare il codice già presente, *ricomponendolo* e *riciclandolo*.

![[Pasted image 20241126124914.png]]

A sinistra abbiamo il codice che vogliamo eseguire, riciclato dal programma già presente.

![[Pasted image 20241126125210.png]]
![[Pasted image 20241126125219.png]]
![[Pasted image 20241126125228.png]]

# Contromisure

![[Pasted image 20241126125501.png]]





# Esempi

```C

	char shellcode[] = 
	"codifica in binario di istruzioni assembly"

(*(void(*)())shellcode)();
```


Se uso gets() posso andare fuori dal buffer di input 64 byte e scrivere sullo stack.